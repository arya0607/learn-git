# git 02

15-131

## Shorthand with some commands

Let's make a simple repo. We'd usually do that with

	$ mkdir simple
	$ cd simple
	$ git init
	Initialized empty Git repository in ...

We can do that with 2 commands instead of 3 with

	$ git init simple
	Initialized empty Git repository in ...
	$ cd simple

## Shorthand with some commands

Let's add and commit some files.

	$ touch {a,b,c}.txt
	$ git add {a,b,c}.txt
	$ git commit -m 'start'
	[master (root-commit) 6c3f5b3] start
	 3 files changed, 0 insertions(+), 0 deletions(-)
	 create mode 100644 a.txt
	 create mode 100644 b.txt
	 create mode 100644 c.txt

Let's make a new branch and switch to it. We'd usually do that with

	$ git branch test
	$ git checkout test
	Switched to branch 'test'

We can do that in one with

	$ git checkout -b test
	Switched to a new branch 'test'

## Merge conflicts

On our new branch, let's modify some files.

	$ echo hey >> a.txt
	$ echo hey >> b.txt

And commit.

	$ git add {a,b}.txt
	$ git commit -m 'modify a and b'
	[test 40b34cd] modify a and b
	 2 files changed, 2 insertions(+)

## Merge conflicts

Back on `master`:

	$ git checkout master
	Switched to branch 'master'
	$ echo hello >> b.txt
	$ echo hello >> c.txt
	$ git add {b,c}.txt
	$ git commit -m 'modify b and c'
	[master 2b0ae7d] modify b and c
	 2 files changed, 2 insertions(+)

## Merge conflicts

Now, let's suppose we want to merge `test` into `master`.

Here's a problem, though. We modified `b.txt` in both `test` and `master`. Not
only that, but we modified the same _line_ of `b.txt`. Because of this, git
isn't going to be able to figure out which "version" of `b.txt` is the "right"
one.

	$ git merge test
	Auto-merging b.txt
	CONFLICT (content): Merge conflict in b.txt
	Automatic merge failed; fix conflicts and then commit the result.

## Merge conflicts

A good strategy: look at the status.

	$ git status
	On branch master
	You have unmerged paths.
	  (fix conflicts and run "git commit")
	  (use "git merge --abort" to abort the merge)

	Changes to be committed:

		modified:   a.txt

	Unmerged paths:
	  (use "git add <file>..." to mark resolution)

		both modified:   b.txt

We see that `a.txt`, which we modified on the `test` branch, doesn't have merge
conflicts. But `b.txt` does.

## Merge conflicts

What does `b.txt` look like right now?

	$ cat b.txt
	<<<<<<< HEAD
	hello
	=======
	hey
	>>>>>>> test

We see that git is showing us the way this line of `b.txt` looked both in
`HEAD` (i.e. `master`, the currently checked-out commit), and in `test` (i.e.,
the branch we're trying to merge).

## Merge conflicts

Let's resolve the merge conflict ourselves.

	$ vim b.txt
	...
	$ cat b.txt
	hey, hello there

And then, tell git the conflict is resolved by adding `b.txt` to the index.

	$ git add b.txt
	$ git commit
	[master 78aa74d] Merge branch 'test'

## Remote repositories

Let's suppose we want to contribute to a project a lot of other people are
working on. Many projects, both open-source and private, host their git
repositories on a server.

In order for us to work on a project, we first have to have the project on our
computer. So, given the URL where the project is accessible on the remote
server, we clone the repository.

	$ git clone <url>

Then, the status:

	$ git status
	On branch master
	Your branch is up to date with 'origin/master'.

	nothing to commit, working tree clean

We can think of `origin` as representing the remote repository. `origin/master`
is the `master` branch on the remote repository.

## Remote repositories

Now, we can make some local commits. Let's make them on our local `master`
branch (the usual default branch.)

After we make commits locally, we can make our local commits available for
everyone else to see. We can say

	$ git push origin master

to mean, "Make it so that the `master` branch on the `origin` repository is
up-to-date with the `master` branch on my local repository."

## Remote repositories

Let's suppose we've been told there's important new commits available that
another developer made, and pushed to `origin`. We want to get those commits.

We can say

	$ git pull origin master

to mean, "Make it so that the `master` branch of my local repository is
up-to-date with the `master` branch of the `origin` repository." Basically, the
complement of `git pull`.
